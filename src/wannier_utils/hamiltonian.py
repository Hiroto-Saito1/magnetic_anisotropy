#!/usr/bin/env python

from copy import deepcopy
import gzip
from itertools import product
from pathlib import Path
from traceback import format_exc
from typing import Iterable, Optional, Tuple, Union

import numpy as np
from scipy.constants import Boltzmann, eV
from scipy.special import expit

from wannier_utils.fourier import Fourier
from wannier_utils.logger import get_logger

logger = get_logger(__name__)


class HamR:
    """
    Hamiltonian generated by Wannier90 code.
    All units are eV and A.

    Attributes:
        a: real-space lattice vectors in (3, 3) array.
        num_wann: the number of Wannier orbitals.
        nrpts: the number of unit cells.
        ndegen: degeneracies of Wigner-Seitz grid points in (nrpts) array.
        irvec: lattice vectors for unit cells in (nrpts, 3) array.
        ir0: index of H(0). If not found, return -1.
        hrs: Wannier-based Hamiltonian in (nrpts, num_wann, num_wann) array.
    """

    def __init__(
        self, 
        tb_dat: Optional[Path] = None, 
        hr_dat: Optional[Path] = None, 
        is_reorder: bool = False, 
    ):
        """
        Constructor.

        Args:
            tb_dat: wannier_tb.dat file path. defaults to None.
            hr_dat: wannier_hr.dat file path. defaults to None.
            is_reorder: whether to reorder indices of Wannier orbitals in dat file. defaults to False.
        """
        if tb_dat:
            self._read_tb(tb_dat, is_reorder)
        elif hr_dat:
            self._read_hr(hr_dat, is_reorder)
        else:
            raise ValueError("Neither tb_dat nor hr_dat is given.")

    def _read_tb(self, tb_dat: Path, is_reorder: bool):
        """
        Read wannier_tb.dat file.

        Additional attributes:
            Amnrs: Wannier-based position matrix in (nrpts, num_wann, num_wann, 3) array.
        """
        logger.info("Reading {} ...".format(str(tb_dat)))
        try:
            if tb_dat.is_file():
                fp = open(tb_dat, mode="r")
            elif tb_dat.with_suffix(tb_dat.suffix + ".gz").is_file():
                fp = gzip.open(tb_dat.with_suffix(tb_dat.suffix + ".gz"), mode="rt")
            else:
                raise ValueError("{} is not found.".format(str(tb_dat)))
            fp.readline()   # empty line
            self.a = np.zeros((3, 3), dtype=np.float64)
            for i in range(3):
                self.a[i] = np.array([float(x) for x in fp.readline().split()])
            self.num_wann = int(fp.readline())
            self.nrpts = int(fp.readline())

            ndegen = []
            for i in range(self.nrpts//15 + 1):
                ndegen += map(int, fp.readline().split())
                if len(ndegen) >= self.nrpts: break
            self.ndegen = np.array(ndegen, dtype=np.int64)

            self.hrs = np.zeros((self.nrpts, self.num_wann, self.num_wann), dtype=np.complex128)
            self.irvec = np.zeros((self.nrpts, 3), dtype=np.int64)

            self.ir0 = -1
            for i in range(self.nrpts):
                fp.readline()   # empty line
                (irx, iry, irz) = fp.readline().split()
                self.irvec[i] = np.array([int(x) for x in [irx, iry, irz]])
                if np.all(self.irvec[i] == 0):
                    self.ir0 = i
                for m, n in product(range(self.num_wann), repeat=2):
                    (_, _, tr, ti) = fp.readline().split()
                    if is_reorder:
                        # VASP, wannier ver1. etc
                        mr = m//2 + (self.num_wann//2)*(m%2)
                        nr = n//2 + (self.num_wann//2)*(n%2)
                        self.hrs[i, nr, mr] = float(tr) + float(ti)*1j
                    else:
                        # normal order
                        self.hrs[i, n, m] = float(tr) + float(ti)*1j

            self.Amnrs = np.zeros(
                (self.nrpts, self.num_wann, self.num_wann, 3), 
                dtype=np.complex128, 
            )
            a = np.zeros((3), dtype=np.complex128)
            for i in range(self.nrpts):
                fp.readline()  # empty line
                (irx, iry, irz) = fp.readline().split()
                self.irvec[i] = np.array([int(x) for x in [irx, iry, irz]])
                if (np.all(self.irvec[i] == 0)):
                    self.ir0 = i
                for m, n in product(range(self.num_wann), repeat=2):
                    (_, _, axr, axi, ayr, ayi, azr, azi) = fp.readline().split()
                    a[0] = float(axr) + 1j*float(axi)
                    a[1] = float(ayr) + 1j*float(ayi)
                    a[2] = float(azr) + 1j*float(azi)
                    if is_reorder:
                        # VASP, wannier ver1. etc
                        mr = m//2 + (self.num_wann//2)*(m%2)
                        nr = n//2 + (self.num_wann//2)*(n%2)
                        self.Amnrs[i, nr, mr, :] = a[:]
                    else:
                        # normal order
                        self.Amnrs[i, n, m, :] = a[:]
            fp.close()

            logger.info("Reading {} is Done.".format(str(tb_dat)))
            logger.debug("Wannier center from Amnrs:")
            for n in range(self.num_wann):
                logger.debug(
                    "{0:3d} {1[0]:15.8f} {1[1]:15.8f} {1[2]:15.8f}"\
                    .format(n, self.Amnrs[self.ir0, n, n, :].real)
                )

        except Exception:
            logger.error(format_exc())

    def _read_hr(self, hr_dat: Path, is_reorder: bool):
        """
        read wannier_hr.dat file.
        """
        logger.info("Reading {} ...".format(str(hr_dat)))
        try:
            if hr_dat.is_file():
                fp = open(hr_dat, mode="r")
            elif hr_dat.with_suffix(hr_dat.suffix + ".gz").is_file():
                fp = gzip.open(hr_dat.with_suffix(hr_dat.suffix + ".gz"), "rt")
            else:
                raise ValueError("{} is not found.".format(str(hr_dat)))
            fp.readline()   # empty line
            self.num_wann = int(fp.readline())
            self.nrpts = int(fp.readline())

            ndegen = []
            for i in range(self.nrpts//15 + 1):
                ndegen += map(int, fp.readline().split())
                if len(ndegen) >= self.nrpts: break
            self.ndegen = np.array(ndegen)

            self.hrs = np.zeros((self.nrpts, self.num_wann, self.num_wann), dtype=np.complex128)
            self.irvec = np.zeros((self.nrpts, 3), dtype=np.int64)
            self.ir0 = -1
            for i, (m, n) in product(range(self.nrpts), product(range(self.num_wann), repeat=2)):
                (irx, iry, irz, _, _, tr, ti) = fp.readline().split()
                if (m == 0 and n == 0):
                    self.irvec[i] = np.array([int(x) for x in [irx, iry, irz]])
                    if np.all(self.irvec[i] == 0):
                        self.ir0 = i
                if is_reorder:
                    # VASP, wannier ver1. etc
                    mr = m//2 + (self.num_wann//2)*(m%2)
                    nr = n//2 + (self.num_wann//2)*(n%2)
                    self.hrs[i, nr, mr] = float(tr) + float(ti)*1j
                else:
                    # normal order
                    self.hrs[i, n, m] = float(tr) + float(ti)*1j
            fp.close()
            logger.info("Reading {} is Done.".format(str(hr_dat)))

        except Exception:
            logger.error(format_exc())

    def export(self, file_name: Union[str, Path]):
        try:
            with open(file_name, mode="w") as fp:
                fp.write("created by wannier_utils\n")
                fp.write(str(self.num_wann) + "\n")
                fp.write(str(self.nrpts) + "\n")
                ndeg_str = "%5d" * self.nrpts % tuple(self.ndegen)
                fp.writelines([ndeg_str[i:i + 75] + "\n" for i in range(0, len(ndeg_str), 75)])
                for i, (m, n) in product(range(self.nrpts), product(range(self.num_wann), repeat=2)):
                    hr = self.hrs[i, n, m]
                    fp.write(
                        ("%5d" * 5 + "%12.6f" * 2 + "\n") % \
                        (tuple(self.irvec[i]) + \
                            (n + 1, m + 1, hr.real, hr.imag)
                        )
                    )
        except:
            raise ValueError("Failed to export to {}.".format(str(file_name)))

    def project_both(self, m: np.ndarray, indexes: Iterable[int]):
        p = np.zeros((self.num_wann, self.num_wann))
        for i in indexes:
            p[i, i] = 1
        return np.matmul(np.matmul(p, m), p)

    def project_half(self, m: np.ndarray, indexes: Iterable[int]):
        p = np.zeros((self.num_wann, self.num_wann))
        for i in indexes:
            p[i, i] = 1
        return np.matmul(p, m)


def merge(ham_r1: HamR, ham_r2: HamR, weight1: float, weight2: float) -> HamR:
    """
    return H1*weight1 + H2*weight2.

    Args:
        ham_r1, ham_r2: HamR instances.
        weight1, weight2: superposition weights of each ham_r.

    Returns:
        HamR: superposed HamR instances.
    """
    ham_r_copy = deepcopy(ham_r1)
    ham_r_copy.hrs = ham_r1.hrs*weight1 + ham_r2.hrs*weight2
    return ham_r_copy


def split_spin(ham_r: HamR, prefix: str):
    """
    split Hamiltonian into up-spin Hamiltonian and down-spin Hamiltonian.

    Args:
        ham_r: a HamR instance.
        prefix: prefix of filename. prefix_up_hr.dat and prefix_dn_hr.dat are generated.
    """
    ham_r_copy = deepcopy(ham_r.hrs)
    ham_r.num_wann //= 2
    ham_r.hrs = ham_r_copy[:, 0::2, 0::2]
    ham_r.export(prefix + "_up_hr.dat")
    ham_r.hrs = ham_r_copy[:, 1::2, 1::2]
    ham_r.export(prefix + "_dn_hr.dat")


class HamK:
    """
    k-dependent information of HamR.

    Args:
        ham_r (HamR): a HamR instance.
        k (np.ndarray): a k point in fractional coordinates.
        rc (Optional[np.ndarray]): position of Wannier centers in fractional coordinates, 
                                   (num_wann, 3) numpy array. 
                                   defaults to None.
        diagonalize (bool): whether to get eigenvalues and eigenvectors, 
                            defaults to False.

    Attributes:
        ham_r
        k
        ek (np.ndarray): eigenvalues of H(k).
        uk (np.ndarray): eigenvectors of H(k).

    Notes: 
        See Yates et al., PRB 75, 195121 (2007) for naming convention of 
        instance variables in this class.
    """
    def __init__(
        self, 
        ham_r: HamR, 
        k: np.ndarray, 
        rc: Optional[np.ndarray] = None, 
        diagonalize: bool = False, 
    ):
        self.ham_r = ham_r
        self.k = k
        self.rc = rc
        self.exp_kr = np.exp(2*np.pi*1j*np.einsum("a,ja->j", self.k, self.ham_r.irvec, optimize=True))
        self._HW, self._HWa = self._get_matrix()
        if diagonalize:
            self.ek, self.uk = np.linalg.eigh(self.hk)

    def _get_matrix(self) -> Tuple[np.ndarray, np.ndarray]:
        """
        calculate H(k) and H_a(k) = dH(k)/da.
        """
        if self.rc is None:
            exp_kr = self.exp_kr/self.ham_r.ndegen
            HW = np.einsum("jmn,j->mn", self.ham_r.hrs, exp_kr, optimize=True)
            r_exp_kr = 1j*np.einsum("ja,j->ja", self.ham_r.irvec, exp_kr, optimize=True)
            HWa = np.einsum("jkl,ja->akl", self.ham_r.hrs, r_exp_kr, optimize=True)
            return HW, HWa
        #kr = np.einsum("a,mnja->mnj", self.k, rvec, optimize=True)
        #exp_kr = np.exp(2*np.pi*1j*kr)/self.ham_r.ndegen[None, None, :]
        exp_krc = np.exp(2*np.pi*1j*np.einsum("a,ja->j", self.k, self.rc, optimize=True))
        exp_kr_krc = self.exp_kr[:, None, None]*exp_krc.conj()[None, :, None]*exp_krc[None, None, :]
        HW = np.einsum("jmn,jmn->mn", self.ham_r.hrs, exp_kr_krc, optimize=True)
        #HW = np.einsum(
        #    "jmn,j,m,n->mn", 
        #    self.ham_r.hrs, self.exp_kr, np.conj(exp_krc), exp_krc, 
        #    optimize=True, 
        #)

        rvec = self.ham_r.irvec[:, None, None, :] \
               - self.rc[None, :, None, :] + self.rc[None, None, :, :]
        HWa = 1j*np.einsum(
            "jmn,jmna,jmn->amn", 
            self.ham_r.hrs, rvec, exp_kr_krc, 
            optimize=True, 
        )
        #HWa = 1j*np.einsum(
        #    "jmn,jmna,j,m,n->amn",
        #    self.ham_r.hrs, rvec, exp_kr, np.conj(exp_krc), exp_krc, 
        #    optimize=True, 
        #)
        return HW, HWa

    @property
    def hk(self) -> np.ndarray:
        return self._HW

    @property
    def HWa(self) -> np.ndarray:
        """
        return H^(W)_a = dH^(W)/da in size of (3, num_wann, num_wann).
        """
        return self._HWa

    @property
    def HHa(self) -> np.ndarray:
        """
        return \bar{H}^(H)_a = dH^(H)/da in size of (3, num_wann, num_wann).
        """
        if not hasattr(self, "uk"): _, self.uk = np.linalg.eigh(self.hk)
        if not hasattr(self, "_HHa"):
            self._HHa = np.einsum(
                "ji,ajk,kl->ail", 
                self.uk.conj(), self.HWa, self.uk, 
                optimize=True,
            )
        return self._HHa

    @property
    def va(self) -> np.ndarray:
        """
        return v_a = {H^(H)_a}_nn in size of (3, num_wann).
        """
        if not hasattr(self, "uk"): _, self.uk = np.linalg.eigh(self.hk)
        if not hasattr(self, "_va"):
            self._va = np.einsum(
                "ji,ajk,ki->ai", 
                self.uk.conj(), self.HWa, self.uk, 
                optimize=True,
            )
        return self._va

    @property
    def vmna(self) -> np.ndarray:
        """
        return v_mna = \bar{H}^{H}_mna - i*(e_n - e_m)\bar{A}^{H}_mna in size of 
        (3, num_wann, num_wann).
        """
        if not hasattr(self, "uk"): self.ek, self.uk = np.linalg.eigh(self.hk)
        if not hasattr(self, "_vmna"):
            bHHmna = np.einsum(
                "jm,ajk,kn->amn", 
                self.uk.conj(), self.HWa, self.uk, 
                optimize=True, 
            )
            bAHmna = np.einsum(
                "jm,jka,kn->amn", 
                self.uk.conj(), self.AWmna, self.uk, 
                optimize=True, 
            )
            self._vmna = bHHmna - 1j*(self.ek[None, None, :] - self.ek[None, :, None])*bAHmna
        return self._vmna

    @property
    def AWmna(self) -> np.ndarray:
        """
        return A^{W}_mna in size of (num_wann, num_wann, 3).
        """
        if not hasattr(self, "_AWmna"):
            exp_kr = self.exp_kr/self.ham_r.ndegen
            self._AWmna = np.einsum("jmna,j->mna", self.ham_r.Amnrs, exp_kr, optimize=True)
        return self._AWmna

    @property
    def HWab(self) -> np.ndarray:
        """
        return H^{W}_ab = d^{2}H^{W}/dadb in size of (3, 3, num_wann, num_wann).
        """
        if not hasattr(self, "_HWab"):
            exp_kr = self.exp_kr/self.ham_r.ndegen
            exp_kr_ab = -np.einsum(
                "ja,jb,j->jab", 
                self.ham_r.irvec, self.ham_r.irvec, exp_kr, 
                optimize=True, 
            )
            self._HWab = np.einsum("jab,jmn->abmn", exp_kr_ab, self.ham_r.hrs, optimize=True)
        return self._HWab


    @property
    def DHa(self) -> np.ndarray:
        """
        return D^{H}_nma = H^{H}_nma/(e_m - e_n)
        """
        if not hasattr(self, "ek"): self.ek = np.linalg.eigvalsh(self.hk)
        if not hasattr(self, "_DHa"):
            ediff = self.ek[None, :] - self.ek[:, None]
            ind = np.abs(ediff) < 1e-6
            ediff[ind] = 1e-10
            einv = 1/ediff
            einv[ind] = 0
            self._DHa = np.einsum("amn,mn->amn", self.HHa, einv, optimize=True)
        return self._DHa

    @property
    def ma(self) -> np.ndarray:
        """
        """
        if not hasattr(self, "uk"): _, self.uk = np.linalg.eigh(self.hk)
        if not hasattr(self, "_ma"):
            HHnnab = np.einsum(
                "ji,abjk,ki->abi", 
                self.uk.conj(), self.HWab, self.uk, 
                optimize=True,
            )
            HaDb = 2*np.einsum("aij,bji->abi", self.HHa, self.DHa).real
            self._ma = HHnnab + HaDb
        return self._ma

    def convert_wan_to_ham(self, mat: np.ndarray) -> np.ndarray:
        """
        change Wannier-gauge matrix to Hamilton gauge.

        Args:
            mat: Wannier-gauge matrix.
        """
        if not hasattr(self, "uk"): _, self.uk = np.linalg.eigh(self.hk)
        return np.einsum("mp,mn,nq->pq", self.uk.conj(), mat, self.uk, optimize=True)

    def convert_ham_to_wan(self, mat: np.ndarray) -> np.ndarray:
        """
        change Hamilton-gauge matrix to wannier gauge.

        Args:
            mat: Hamlton-gauge matrix.
        """
        if not hasattr(self, "uk"): _, self.uk = np.linalg.eigh(self.hk)
        return np.einsum("mp,pq,nq->mn", self.uk, mat, self.uk.conj(), optimize=True)

    def get_fermi(self, mu_range: np.ndarray, tmpr_range: np.ndarray) -> np.ndarray:
        """
        return Fermi distribution function.

        Args:
            mu_range: chemical potential in unit of eV.
            tmpr_range: temperature in unit of K.

        Returns:
            (e.size, mu_range.size, tmpr_range.size) numpy array.
        """
        if not hasattr(self, "ek"): self.ek = np.linalg.eigvalsh(self.hk)
        tmpr_range_eV = tmpr_range*Boltzmann/eV
        x = (self.ek[:, None, None] - mu_range[None, :, None])/tmpr_range_eV[None, None, :]
        return expit(-x)

    def get_minus_d_fermi(self, mu_range: np.ndarray, tmpr_range: np.ndarray) -> np.ndarray:
        """
        return minus-derivative of Fermi distribution function (-df/de).

        Args:
            mu_range: chemical potential in unit of eV.
            tmpr_range : temperature in unit of K.

        Returns:
            (e.size, mu_range.size, tmpr_range.size) numpy array.
        """
        if not hasattr(self, "ek"): self.ek = np.linalg.eigh(self.hk)
        tmpr_range_eV = tmpr_range*Boltzmann/eV
        x = (self.ek[:, None, None] - mu_range[None, :, None])/tmpr_range_eV[None, None, :]
        return expit(x)*expit(-x)/tmpr_range_eV[None, None, :]
